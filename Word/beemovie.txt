\documentclass[twoside]{article}
\title{Graded exercise 3}
\author{WRITE YOUR NAME HERE
  \\ CSC311 Systems Software}
\date{07 February 2018}

\usepackage{listings}
\lstset{language=c,numbers=left,stepnumber=1}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}

\begin{document}
\maketitle

\section*{Unix and Linux}

\subsection*{Origins of Unix}

Unix is a operating system, or a  set of computer operating system, that come from AT&T and is written in C and assembly language. The development of Unix started at Bell Labs in the 1970s by Ken Tompson, Dennis Ritchie, and others. It was originally just for the Bell System, but AT&T gave Unix to outside organizations which led to many variats of the commercial Unix. Over the years, many Unix-like operating systems have ben developed but Linux is the most popular.

\subsection*{Origins of Linux}

Linux was started in 1991 by the Finnish student named Linux Torvalds when he introduced a new operating system kernel. While studying at the University of Helsinki, Linus wrote Linux specifically for his computer and independent of an operating system because he wanted to use the functions of his new PC. It was developed on MINIX using the GNU C compiler which is still the main choice for compiling Linux.

\subsection*{Linux Today}

Currently there are hundreds of variations of Linux that are for different hardware devices and systems or sofware configurations. The most popular of these include Ubuntu, Mint, Debian and Fidora. It is insteresting to note that the word's top 500 supercomputers run the Linux operating system. Also it is the leading operating system on servers and other big systems like mainframe computers, but only 2.3\% of desktop computers use it.

\subsection*{Distinguishing Features}

Linux is a very popular operating system for a lot of reasons and here are some. First it is portable, meaning it can work on different types of hardware in the same way and the kernel supports their installation on any kind of hardware platform. Second it is open source so it's freely available and is a community based development project. Also it has such a long life becuase it has many patches for the system. And finally it's so popular because it is used everywhere, from smartphones to TVs and routers.


\section*{Systems Programming}

\subsection*{Purpose and Intended Audience}

Systems programming or system software is designed to operate and control the computer hardware and to provide a platfrom for application software. Categories that fit into system sofwate include operating systems, untility software, device drivers, compilers, and linkers. A systems programmer works for people who need a basis to build their own software on, they do this by operating on Device Drivers, Firmware, and Operating sytems. The purpose of their job is to make the sure that people can write their own software without them having any problems, but it is difficult because systems programmers do not have a net to catch them, if they screw up systems crash. People who use systems software are called applications programmers, or userland programmers.


\subsection*{Discipline}

To develop systems software what is usually used is fairly low-level programming languages and tools. Systems programmers have to be aware about the hardware and properties of the systmes that the programs wil run on so they can use the best algorithms for it. These programmers have to make sure that programs can operate in resource-constrained environments, that programs have little runtime, and that programs can use direct control over memory access. Also to write systems software the programs have to be run in a simulated environment becuase they cannot be run in a debugger. From this definition it easy already apparent that systems programming is different from software engineering, but here are some more differences. First, in system programming, limited programming facilites are available, for example the use of automatic garbage collection is not common and debugging is hard to do. Also the runtime library, if available is not powerful and does less error checking


\subsection*{Lessons Learned}

Coming from many classes where we used high level languages like python and java, memory and the calls that the system made weren't a concern to us. This was because since the languages were more advanced and higher up they had their own error checking and event handling but C is not a high level language. I have learned through this class that taking the time to learn how to allocate memory in C and how pointers work will give you a very good start in systems programming. Although pointers seem confusing at first, once you get the hang of them they are very useful for improving the performance of traversing strings, control tables, and tree structures. It is important that you understand the system calls and that you error check after each one so you know where the error occured and to know why. Also it is very important to learn about structs in C because they open the possiblity for many intersting and useful data structures.


\section*{Project}

\subsection*{Running the Program}

The first day that we started the project, counting the occurences of the characters in a text file, I was interested in counting the words of a text document as well. At first I made two arrays, one of ints and the other a 2d array of chars. I did a basic approach to this problem of counting the words by storing each word in the 2d array and when adding a new word, I checked to see if it was in the array and if so updated the int array. This took too much time and was not effecient at all, so my first goal was to create a good data structure for this problem. I first tried a BST but that didn't really go well with the issue, so then I looked at a hash table and that seemed like the best method. After I finished making the structs for a hash table I wanted to make functions that let add words to the array. I had to generate a hash index which I did by adding up the ASCII values. Then my next goal was to make a function that itterated through the array at the end, went through each linked list, and ultimately printing out all the words and their count. This wasn't too hard and it helped my final goal of being able to search for a word and produce its count and the average time it appeared in relation to the total amount of words. So in the end I achieved my original goal of getting all the words in a text file, their count, and putting them in a very efficient data structure.


\begin{lstlisting}{}

  This is how I read in the the text file, it is similar to what we did in class. It takes a text file, and reads it into the read and line variables to be parsed.

  void wordcount(ssize\_t read, size\_t len, FILE * inputstream,
  char *line, int *letterz){
  while ((read = getline(&line, &len, inputstream)) != -1){
    if( read > 0 ){
      for(int k = 0; line[k]; k++){
        if(line[k] >= '0' <= 9 ){
          //printf("%s\n", "help" );
          //line[k] = ' ';
        }

  \end{lstlisting}

\subsection*{Goals}

To achieve my goals of making a efficient data structure and the functions to go with it I needed to learn about structs. I looked on the web to see examples of structs and from there I got a pretty good idea how they worked. The structs I used were fairly simple, just nodes with counts and names linked to their next nodes and a struct array that held these nodes. Also I needed to understand pointers better so I looked up some tutorials and guides on what they are and how to used them. I needed pointers to update my original nodes in my array when I transversed my temporary nodes. A couple times I got stuck so Galbraith and I teamed up to tackle some of these problems but most of my work was done independent.

\begin{lstlisting}{}

These three parts of the code are very importat because they are the basis of what a hash table is. The nodes are the values in the hash table, the hash struct holds these nodes, and my hashnum function gives the index of where to store the word


struct node {
    char name[100];
    struct node *next;
    int count;
};

struct hash {
    struct node *head;
    int count;
};

int hashnum(char *name){
  int returnval = 0;
  //minus 96 becuase a starts at 1
  for(int i = 0; i < strlen(name); i ++){
    returnval += ((int)name[i] - 96);
  }
  //negative values for non letters
  if(returnval < 0){
    return (returnval * -1);
  }
  else{
  return returnval % size;
}
}



  \end{lstlisting}

\subsection*{Methods}

I didn't need to use very many system calls in my program because most of it had to deal with structs. I did use the fopen system call to read the text file into a FILE variable. After I did this I made sure to error check and return 1 if the file returned null. I also used a couple of library functions include strcpy which I used to put the words into the name parts on my nodes, strtok to seperate the words in a line so I could read them into my hash structure, and most oftenly used strcmp to check if two strings where equal, which was useful for searching for words and increasing the count on nodes. One last one I used was alos strlen, which I needed to compute the ASCII value for the hash index of a word.


\begin{lstlisting}{}

  One final piece of my code is probably the one that took the longest. This is the part of my program where I add a node to the hash array. I first check to see if there is a node where I am indexing and if there isn't I set the node equal to the head. If there is a word there I check to see if any of the words that are linked together are the same, and if they are I add 1 to that word. Finally if none of those return I have found a word with the same ASCII value as another where they aren't the same word. Then I link that word to the first.

void insertToHash(char *name) {
    int hashIndex = hashnum(name);
    //printf("%s\n", name );
    struct node *newnode = createNode(name);
    struct node *iteraten = createNode(name);
    //if it is the head or not
    if (!hashTable[hashIndex].head) {
      //printf("%s\n", "Help" );
        hashTable[hashIndex].head = newnode;
        //shows something is in it
        hashTable[hashIndex].count = 1;
        return;
    }
    iteraten = hashTable[hashIndex].head;
    //keep going till null
    while(iteraten != NULL){
      if(!strcmp((iteraten->name), name)){
        //printf("%s\n", "Help" );
        iteraten->count += 1;
        return;
      }
      else{
        iteraten = iteraten->next;
        continue;
      }
    }
    //if it isn't the head or a repeat word
    newnode->next = (hashTable[hashIndex].head);
    hashTable[hashIndex].head = newnode;
    return;
}

  \end{lstlisting}

\end{document}
